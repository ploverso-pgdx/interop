/** Lazy parameter generation of a persistent std::vector
 *
 *  @note This code may only work with gtest 1.7.0
 *
 *  @file
 *  @date 6/23/16
 *  @version 1.0
 *  @copyright GNU Public License.
 */
#pragma once
#include <gtest/gtest.h>


namespace illumina{ namespace interop { namespace unittest {
    /** Data structure that holds the parameters
     *
     * This holds a reference to the input vector, so ensure it is not on the stack!
     *
     * @note This code may only work with gtest 1.7.0
     */
    template<typename T>
    class argument_generator : public ::testing::internal::ParamGeneratorInterface<T>
    {
    public:
        /** Constructor
         *
         * @param vec reference to persistent vector of values
         */
        argument_generator(const std::vector<T>& vec) : m_vec(vec){}
        /** Iterator to start of parameter collection
         *
         * @return iterator to start of parameter collection
         */
        ::testing::internal::ParamIteratorInterface<T>* Begin() const;
        /** Iterator to end of parameter collection
         *
         * @return iterator to end of parameter collection
         */
        ::testing::internal::ParamIteratorInterface<T>* End() const;

    private:
        const std::vector<T>& m_vec;
    };
    /** Iterator over persistent vector of arguments
     *
     * @note This code may only work with gtest 1.7.0
     */
    template<typename T>
    class argument_iterator : public ::testing::internal::ParamIteratorInterface<T>
    {
        typedef typename std::vector<T>::const_iterator const_iterator;
    public:
        /** Constructor
         *
         * @param base generator base
         * @param it iterator to std::vector
         */
        argument_iterator(const argument_generator<T>& base, const_iterator it) : m_base(base), m_begin(it), m_current(it)
        {
        }
        /** Destructor */
        virtual ~argument_iterator() {}
        /** A pointer to the base generator instance.
         * Used only for the purposes of iterator comparison
         * to make sure that two iterators belong to the same generator.
         *
         * @return base generator
         */
        virtual const ::testing::internal::ParamGeneratorInterface<T>* BaseGenerator() const
        {
            return &m_base;
        }
        /** Advances iterator to point to the next element
         * provided by the generator. The caller is responsible
         * for not calling Advance() on an iterator equal to
         * BaseGenerator()->End().
         *
         *
         */
        virtual void Advance()
        {
            ++m_current;
        }
        /** Clones the iterator object. Used for implementing copy semantics
         * of ParamIterator<T>.
         *
         * @return new instance to object
         */
        virtual ::testing::internal::ParamIteratorInterface<T>* Clone() const
        {
            return new argument_iterator(*this);
        }
        /** Dereferences the current iterator and provides (read-only) access
         * to the pointed value. It is the caller's responsibility not to call
         * Current() on an iterator equal to BaseGenerator()->End().
         * Used for implementing ParamGenerator<T>::operator*().
         *
         * @return pointer to current value
         */
        virtual const T* Current() const
        {
            return &(*m_current);
        }
        /** Determines whether the given iterator and other point to the same
         * element in the sequence generated by the generator.
         * Used for implementing ParamGenerator<T>::operator==().
         *
         * @param other other iterator
         * @return true if the base and iterator match
         */
        virtual bool Equals(const ::testing::internal::ParamIteratorInterface<T>& other) const
        {
            return &m_base == other.BaseGenerator() &&
                    m_current == dynamic_cast<const argument_iterator<T>*>(&other)->m_current;
        }
    private:
        argument_iterator(const argument_iterator<T>& other)
                : m_base(other.m_base), m_begin(other.m_begin),
                m_current(other.m_current) {}
    private:
        const argument_generator<T>& m_base;
        const const_iterator m_begin;
        const_iterator m_current;
    };


    template<typename T>
    ::testing::internal::ParamIteratorInterface<T>* argument_generator<T>::Begin() const
    {
        return new argument_iterator<T>(*this, m_vec.begin());
    }
    template<typename T>
    ::testing::internal::ParamIteratorInterface<T>* argument_generator<T>::End() const
    {
        return new argument_iterator<T>(*this, m_vec.end());
    }

    /** Generate parameters from a persistent vector (cannot be on the stack!)
     *
     * @note This code may only work with gtest 1.7.0
     * @param values list of values
     * @return parameter generator
     */
    template<typename T>
    ::testing::internal::ParamGenerator<T> PersistentValuesIn(const std::vector<T>& values) {
        return ::testing::internal::ParamGenerator<T>(new argument_generator<T>(values));
    }
}}}

